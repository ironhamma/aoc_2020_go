package day2

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

//Generated by AoC helper tool 🎄
//In order to get started, extend main.go so it discovers and runs this file as well

type Day2Solver struct{}

type PassWordPolicy struct {
	min  int
	max  int
	char string
}

type Checkable interface {
	Check(chan bool)
	CheckNew(chan bool)
}

type Password struct {
	pass   string
	policy PassWordPolicy
}

func (p *Password) Check(writeChan chan bool) {
	count := 0

	splitted := strings.Split(p.pass, "")

	for _, val := range splitted {
		if val == p.policy.char {
			count += 1
		}
	}

	if count < p.policy.min || count > p.policy.max {
		writeChan <- false
		time.Sleep(time.Second)
		return
	}

	writeChan <- true
	time.Sleep(time.Second)
}

func (p *Password) CheckNew(writeChan chan bool) {
	splitted := strings.Split(p.pass, "")

	hadOne := false
	hadBoth := false

	if splitted[p.policy.min-1] == p.policy.char {
		hadOne = true
	}

	if splitted[p.policy.max-1] == p.policy.char {
		if hadOne {
			hadBoth = true
		} else {
			hadOne = true
		}
	}

	if hadBoth || !hadOne {
		writeChan <- false
		time.Sleep(time.Second)
		return
	}
	writeChan <- true
	time.Sleep(time.Second)
}

func (d Day2Solver) Solve(filename string, answerChan chan int, doneChan chan bool, errorChan chan error) {
	start := time.Now()
	defer close(answerChan)
	defer close(errorChan)
	defer close(doneChan)
	file, err := os.Open(filename)

	if err != nil {
		errorChan <- err
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)

	pwds := []Password{}

	for scanner.Scan() {
		text := scanner.Text()

		split := strings.Split(text, ": ")
		beginning := strings.Split(split[0], " ")
		split2 := strings.Split(beginning[0], "-")

		char := beginning[1]
		p, _ := strconv.ParseInt(split2[0], 10, 64)
		min := p
		p2, _ := strconv.ParseInt(split2[1], 10, 64)
		max := p2
		pass := split[1]

		pwdPol := PassWordPolicy{
			min:  int(min),
			max:  int(max),
			char: char,
		}

		pwds = append(pwds, Password{
			pass:   pass,
			policy: pwdPol,
		})
	}

	writeChan := make(chan bool)
	writeChan2 := make(chan bool)
	counter := 0
	counter2 := 0
	var mu sync.Mutex
	var mu2 sync.Mutex

	go func() {
		for value := range writeChan {
			if value {
				mu.Lock()
				counter++
				mu.Unlock()
			}
		}
	}()

	go func() {
		for value := range writeChan2 {
			if value {
				mu2.Lock()
				counter2++
				mu2.Unlock()
			}
		}
	}()

	var wg sync.WaitGroup
	for _, p := range pwds {
		wg.Add(1)
		go func(p Password) {
			defer wg.Done()
			p.Check(writeChan)
			p.CheckNew(writeChan2)
		}(p)
	}
	wg.Wait()
	close(writeChan)
	close(writeChan2)

	mu.Lock()
	answerChan <- counter
	mu.Unlock()

	mu2.Lock()
	answerChan <- counter2
	mu2.Unlock()

	end := time.Now()
	elapsed := end.Sub(start)
	fmt.Printf("\n\n⏱️ Execution took %v time! ⏱️\n\n", elapsed)
	time.Sleep(time.Second)
	doneChan <- true
}
