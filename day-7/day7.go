package day7

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

//Generated by AoC helper tool 🎄
//In order to get started, extend main.go so it discovers and runs this file as well

type Day7Solver struct{}

const GOLDEN = "shiny gold bag"

type Bag struct {
	bagType string
	amount  int
	bags    []Bag
}

func parseBag(rule string) Bag {
	split := strings.SplitN(rule, " ", 2)
	bagType := strings.TrimSpace(split[1])
	bagAmount, _ := strconv.ParseInt(split[0], 10, 64)

	if strings.Contains(bagType, ".") {
		bagType = strings.Split(bagType, ".")[0]
	}

	if bagType[len(bagType)-1] == 's' {
		bagType = bagType[:len(bagType)-1]
	}

	return Bag{bagType: bagType, amount: int(bagAmount)}
}

func countBag(bag Bag, bags map[string]Bag) int {
	count := 0
	if bag.bagType == GOLDEN {
		count += bag.amount
	}

	for _, inner := range bag.bags {
		count += countBag(inner, bags)
	}

	if len(bag.bags) == 0 && len(bags[bag.bagType].bags) == 0 {
		return count
	}

	if len(bag.bags) == 0 {
		ruleBag, exists := bags[bag.bagType]
		if exists {
			count += countBag(ruleBag, bags)
		}
	}

	return count
}

func countAllBag(bag Bag, bags map[string]Bag) int {
	count := 0
	count += bag.amount
	fmt.Println(bag.bagType)

	for _, inner := range bag.bags {
		count += countAllBag(inner, bags)
	}

	if len(bag.bags) == 0 && len(bags[bag.bagType].bags) == 0 {
		return count
	}

	if len(bag.bags) == 0 {
		ruleBag, exists := bags[bag.bagType]
		if exists {
			count *= countAllBag(ruleBag, bags)
		}
	}

	return count
}

func (d Day7Solver) Solve(filename string, answerChan chan int, doneChan chan bool, errorChan chan error) {
	start := time.Now()
	defer close(answerChan)
	defer close(errorChan)
	defer close(doneChan)
	file, err := os.Open(filename)

	if err != nil {
		errorChan <- err
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)

	lines := ""
	for scanner.Scan() {
		lines += scanner.Text() + "\n"
	}

	rules := strings.Split(lines, "\n")

	bags := make(map[string]Bag)

	for _, rule := range rules {
		if len(rule) == 0 {
			continue
		}
		split := strings.Split(rule, "s contain ")
		root := split[0]
		other := split[1]

		bag := Bag{bagType: root, amount: 1}

		if strings.Contains(other, "no other") {
			if bag.bagType[len(bag.bagType)-1] == 's' {
				bag.bagType = bag.bagType[:len(bag.bagType)-1]
			}
			bags[root] = bag
			continue
		}

		if !strings.Contains(other, ",") {
			b := parseBag(other)
			bag.bags = append(bag.bags, b)
			bags[root] = bag
			continue
		}

		remain := strings.Split(other, ", ")

		for _, bs := range remain {
			thisbag := parseBag(bs)
			bag.bags = append(bag.bags, thisbag)
		}
		bags[root] = bag
	}

	goldCarry := 0

	for _, bag := range bags {
		if bag.bagType == GOLDEN {
			continue
		}

		amount := countBag(bag, bags)
		if amount > 0 {
			goldCarry++
		}
	}

	fmt.Println(bags[GOLDEN])
	goldStuff := countAllBag(bags[GOLDEN], bags)

	answerChan <- goldCarry
	answerChan <- goldStuff - 1

	end := time.Now()
	elapsed := end.Sub(start)
	fmt.Printf("\n\n⏱️ Execution took %v time! ⏱️\n\n", elapsed)

	time.Sleep(time.Second)
	doneChan <- true
}
