package day3

import (
	"bufio"
	"fmt"
	"os"
	"time"
)

//Generated by AoC helper tool 🎄
//In order to get started, extend main.go so it discovers and runs this file as well

type Day3Solver struct{}

type Forest struct {
	geom []string
}

type Rideable interface {
	Ride(chan int, int, int)
}

func ExtendForest(current []string) []string {
	copy := current
	for i, v := range copy {
		copy[i] += v
	}

	return copy
}

func (f *Forest) Ride(resChan chan int, xStep int, yStep int) {
	x, y := 0, 0
	geom := f.geom

	maxLines := len(geom)

	treeCount := 0

	for y < maxLines {
		if len(geom[y]) < x+xStep {
			geom = ExtendForest(geom)
		}
		if string(geom[y][x]) == "#" {
			treeCount++
		}

		x += xStep
		y += yStep

	}

	resChan <- treeCount
}

func (d Day3Solver) Solve(filename string, answerChan chan int, doneChan chan bool, errorChan chan error) {
	start := time.Now()
	defer close(answerChan)
	defer close(errorChan)
	defer close(doneChan)
	file, err := os.Open(filename)

	if err != nil {
		errorChan <- err
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)

	geom := []string{}

	for scanner.Scan() {
		line := scanner.Text()
		geom = append(geom, line)
	}

	forest := Forest{
		geom: geom,
	}

	resChan := make(chan int)

	steps := [][]int{
		{1, 1},
		{3, 1},
		{5, 1},
		{7, 1},
		{1, 2},
	}

	go forest.Ride(resChan, steps[1][0], steps[1][1])

	result := <-resChan
	close(resChan)

	product := 0

	for _, val := range steps {
		resChan2 := make(chan int)
		go forest.Ride(resChan2, val[0], val[1])
		temp := <-resChan2
		close(resChan2)
		if product == 0 {
			product = temp
		} else {
			product *= temp
		}
	}

	answerChan <- result
	answerChan <- product

	end := time.Now()
	elapsed := end.Sub(start)
	fmt.Printf("\n\n⏱️ Execution took %v time! ⏱️\n\n", elapsed)
	doneChan <- true
}
